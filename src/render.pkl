/// Used for some type of purpose.
@ModuleInfo { minPklVersion = "0.25.0" }
module TsConfig

import "TsConfig.pkl"

import "schema.pkl" as Schema

import "base.pkl" as Base
import "strict.pkl" as Strict
import "strictest.pkl" as Strictest
import "transpiling.pkl" as Transpiling
import "nottranspiling.pkl" as NotTranspiling
import "library.pkl" as Library
import "monorepo.pkl" as Monorepo
import "dom.pkl" as Dom
import "notdom.pkl" as NotDom

const linebreak = "\n"

const ConfigItems: List<Schema.CheatSheetItem> =  List (
    new Schema.CheatSheetItem { 
        name = "esModuleInterop" 
        group = "base"
        groupComment = "/*** Base Items ***/"
        comment = "Emit __esModule interop" 
        },
    new Schema.CheatSheetItem { 
        name = "skipLibCheck"
        group = "base"
        groupComment = ""
        comment = "Skip type checking of declaration files" 
        },
    new Schema.CheatSheetItem { 
        name = "target"
        group = "base"
        groupComment = ""
        comment = "Set the target version of ECMAScript" 
        },
    new Schema.CheatSheetItem { 
        name = "allowJs"
        group = "base"
        groupComment = ""
        comment = "Allow JavaScript files to be compiled"
        },
    new Schema.CheatSheetItem { 
        name = "resolveJsonModule"
        group = "base"
        groupComment = ""
        comment = "Include modules without extension"
        },
    new Schema.CheatSheetItem { 
        name = "moduleDetection"
        group = "base"
        groupComment = ""
        comment = "Detect module type"
        },
    new Schema.CheatSheetItem {
        name = "isolatedModules"
        group = "base"
        groupComment = ""
        comment = "Ensure that each file is a separate module" 
        },

    new Schema.CheatSheetItem { 
        name = "strict"
        group = "strict"
        groupComment = "/*** Strict Items ***/"
        comment = "Enable all strict type checking options"
        },
    new Schema.CheatSheetItem { 
        name = "noUncheckedIndexedAccess"
        group = "strict"
        groupComment = ""
        comment = "Disallow access to non-nullable properties of an object"
        },

    new Schema.CheatSheetItem { 
        name = "declaration"
        group = "library"
        groupComment = "/*** Library Items ***/"
        comment = "Generate declaration files" 
        },

    new Schema.CheatSheetItem { 
        name = "declarationMap"
        group = "monorepo"
        groupComment = "/*** Monorepo Items ***/"
        comment = "Generate source maps for declaration files"
        },
    new Schema.CheatSheetItem { 
        name = "declarationDir"
        group = "monorepo"
        groupComment = ""
        comment = "Output directory for declaration files"
        },
    new Schema.CheatSheetItem { 
        name = "emitDeclarationOnly"
        group = "monorepo"
        groupComment = ""
        comment = "Only output declaration files"
        },

    new Schema.CheatSheetItem { 
        name = "lib"
        group = "notdom"
        groupComment = "/*** Not Using Dom Items ***/"
        comment = "Specify library files to be included in the compilation"
        },

    new Schema.CheatSheetItem { 
        name = "module"
        group = "transpiling"
        groupComment = "/*** Transpiling Items ***/"
        comment = "Specify module code generation"
        },
    new Schema.CheatSheetItem { 
        name = "noEmit"
        group = "transpiling"
        groupComment = ""
        comment = "Do not emit output files"
        },

    new Schema.CheatSheetItem { 
        name = "module"
        group = "nottranspiling"
        groupComment = "/*** Not Transpiling Items ***/"
        comment = "Specify module code generation" 
        },
    new Schema.CheatSheetItem { 
        name = "noEmit"
        group = "nottranspiling"
        groupComment = ""
        comment = "Do not emit output files" 
        },

    new Schema.CheatSheetItem { 
        name = "noUncheckedIndexedAccess"
        group = "strictest"
        groupComment = "/*** Strictest Items ***/"
        comment = "Disallow access to non-nullable properties of an object" 
        },
    new Schema.CheatSheetItem { 
        name = "allowUnusedLabels"
        group = "strictest"
        groupComment = ""
        comment = "Allow unused labels" 
        },
    new Schema.CheatSheetItem { 
        name = "allowUnreachableCode"
        group = "strictest"
        groupComment = ""
        comment = "Allow unreachable code"
        },
    new Schema.CheatSheetItem { 
        name = "exactOptionalPropertyTypes"
        group = "strictest"
        groupComment = ""
        comment = "Require that optional properties are exactly the type they are declared as" 
        },
    new Schema.CheatSheetItem { 
        name = "noFallthroughCasesInSwitch"
        group = "strictest"
        groupComment = ""
        comment = "Disallow fallthrough cases in switch statements" 
        },
    new Schema.CheatSheetItem { 
        name = "noImplicitOverride"
        group = "strictest"
        groupComment = ""
        comment = "Ensure that overriding methods are explicitly marked as such" 
        },
    new Schema.CheatSheetItem { 
        name = "noImplicitReturns"
        group = "strictest"
        groupComment = ""
        comment = "Ensure that all code paths return a value"
        },
    new Schema.CheatSheetItem { 
        name = "noPropertyAccessFromIndexSignature"
        group = "strictest"
        groupComment = ""
        comment = "Disallow property access from index signatures" 
        },
    new Schema.CheatSheetItem { 
        name = "noUncheckedIndexedAccess"
        group = "strictest"
        groupComment = ""
        comment = "Disallow access to non" 
        }
)

function lookupConfigItem(name: String): Schema.CheatSheetItem? = 
    ConfigItems.findOrNull((it) -> it.name == name)

/// Build the TsConfig module with the given configuration.
function runTsConfig(config: Any) = 
      List (
        Base.addBaseItems(Base.Base, config.useBase) +
        Dom.addDomItems(Dom.Dom, config.useDom) + 
        Strict.addStrictItems(Strict.Strict, config.useStrict) +
        Strictest.addStrictestItems(Strictest.Strictest, config.useStrictest) +
        Library.addLibraryItems(Library.Library, config.useLibrary) +
        Monorepo.addMonorepoItems(Monorepo.Monorepo, config.useMonorepo) +
        Transpiling.addTranspilingItems(Transpiling.Transpiling, config.useTranspiling) +
        NotTranspiling.addNotTranspilingItems(NotTranspiling.NotTranspiling, !config.useTranspiling) +
        NotDom.addNotDomItems(NotDom.NotDom, !config.useDom) 
     ).filter((it) -> it != null)[0]

function renderElement(value: Any): String =

    if (value is String) #"\#(value)"#
    else if (value is Boolean) #"\#(value)"#
    else if (value is List) #"[\#(renderElement(value.getOrNull(0)))]"#
    else ""

function renderTsConfigWithComments(config: Schema.CheatSheetItem): String = 
     let (items = runTsConfig(config))
        if (items.isEmpty) 
            "No configuration items selected."
        
        else new Listing<String> {
            for(name, value in items) {
                let (item:ConfigItem? = lookupConfigItem(name))
                new Listing<String> {
                    when (!(item?.groupComment?.isEmpty ?? true)) {
                        linebreak
                        #"\#t\#(item.groupComment)"#
                    }
                    when (item != null) { 
                        #"\#t"\#(item.name)": \#(renderElement(value)), \#t\#t// \#(item.comment)"# 
                        }
                }.join("\n")
            }
        }.toList().filter((line) -> line != null && !line.isEmpty).toListing().join("\n")
