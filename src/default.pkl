module TsConfig.Default

import "schema.pkl" as Schema

typealias TotallyTypescriptConfiguration =
  "Base"
  |"Strict"
  |"Strictest"
  |"Dom"
  |"Library"
  |"Monorepo"
  |"Transpiling"

hidden totallyTypescriptConfigurations: Listing<TotallyTypescriptConfiguration> = new {
  "Base"
  "Strict"
  // "Dom"
  "Transpiling"
}


local ttsConfig: Set<TotallyTypescriptConfiguration> =
  totallyTypescriptConfigurations.fold(Set(), (acc, it) -> acc.add(it))

local useBase: Boolean = ttsConfig.contains("Base")
local useStrict: Boolean = ttsConfig.contains("Strict")
local useStrictest: Boolean = ttsConfig.contains("Strictest")
local useDom: Boolean = ttsConfig.contains("Dom")
local useLibrary: Boolean = ttsConfig.contains("Library")
local useMonorepo: Boolean = ttsConfig.contains("Monorepo")
local useTranspiling: Boolean = ttsConfig.contains("Transpiling")

local useBaseOrStrictest = useBase || useStrictest
local useStrictOrDom = useStrict || useDom
local useStrictOrStrictestOrDom = useStrictOrDom || useStrictest

esModuleInterop: Boolean(useBase)? = if (!useBase) null else true
skipLibCheck: Boolean(useBase)? = if (!useBase) null else true
target: String(useBase)? = if (!useBase) null else "es2022"
allowJs: Boolean(useBase)? = if (!useBase) null else true
resolveJsonModule: Boolean(useBase)? = if (!useBase) null else true
moduleDetection: String(useBase)? = if (!useBase) null else "force"
isolatedModules: Boolean(useBaseOrStrictest)? = if (!useBaseOrStrictest) null else true

strict: Boolean(useStrictOrDom)? = if (!useStrictOrDom) null else true
noUncheckedIndexedAccess: Boolean(useStrictOrStrictestOrDom)? = if (!useStrictOrStrictestOrDom) null else true

allowUnusedLabels: Boolean(useStrictest)? = if (!useStrictest) null else false
allowUnreachableCode: Boolean(useStrictest)? = if (!useStrictest) null else false
exactOptionalPropertyTypes: Boolean(useStrictest)? = if (!useStrictest) null else true
noFallthroughCasesInSwitch: Boolean(useStrictest)? = if (!useStrictest) null else true
noImplicitOverride: Boolean(useStrictest)? = if (!useStrictest) null else true
noImplicitReturns: Boolean(useStrictest)? = if (!useStrictest) null else true
noPropertyAccessFromIndexSignature: Boolean(useStrictest)? = if (!useStrictest) null else true
noUnusedLocals: Boolean(useStrictest)? = if (!useStrictest) null else true
noUnusedParameters: Boolean(useStrictest)? = if (!useStrictest) null else true
checkJs: Boolean(useStrictest)? = if (!useStrictest) null else true
forceConsistentCasingInFileNames: Boolean(useStrictest)? = if (!useStrictest) null else true

declaration: Boolean(useLibrary)? = if (!useLibrary) null else true

declarationMap: Boolean(useMonorepo)? = if (!useMonorepo) null else true
declarationDir: String(useMonorepo)? = if (!useMonorepo) null else "dist"
emitDeclarationOnly: Boolean(useMonorepo)? = if (!useMonorepo) null else true

`module`: String = if (!useTranspiling) "preserve" else "NodeNext"
outDir: String(useTranspiling)? = if (!useTranspiling) null else "dist"
noEmit: Boolean(!useTranspiling)? = if (useTranspiling) null else true

lib: List<String>(!useDom)? = List("es2022")

hidden root: Schema.RootSchema

hidden amend: Schema.AmendSchema

hidden outputFileName:Schema.ValidOutputFileName = "tsconfig.json"

hidden fixed aggregatedConfig = new Mapping {
  ["compilerOptions"] = (module.toDynamic()) {
    ...amend
  }.toMap()
  ...root.toMap()
}

output {
  renderer = new JsonRenderer {
    converters {
      [Boolean] = (it) -> "\(it)"
      [List] = (it) -> "[\(it[0])]"
      [Listing] = (it) -> if (it.isEmpty) null else it
    }
  }
  value = aggregatedConfig
  files {
    [if (outputFileName == "tsconfig.json") "totally_tsconfig.json" else outputFileName] = output
  }
}